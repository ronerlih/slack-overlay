<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
		<link
			rel="stylesheet"
			href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
		/>
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
		/>
		<style>
			html {
				scroll-behavior: smooth;
			}
			::-webkit-scrollbar-track {
				-webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
				background-color: rgba(80, 19, 203, 0.345);
			}
			::-webkit-scrollbar-corner {
				background: rgba(80, 19, 203, 0.645);
			}

			::-webkit-scrollbar {
				width: 6px;
				height: 6px;
				background-color: rgba(80, 19, 203, 0.345);
			}

			::-webkit-scrollbar-thumb {
				background-color: rgba(80, 19, 203, 0.345);
				border: 2px solid rgba(80, 19, 203, 0.645);
			}
		</style>
	</head>
	<body
		style="
			background: rgba(80, 19, 203, 0.345);
			color: white;
			font-family: Verdana, Geneva, Tahoma, sans-serif;
		"
	>
   <header style="position: fixed; top: 10px; right:5px; background-color: rgba(80, 19, 203, 0.845); padding: 6px; border: 1px solid white">

		<img alt="slack_logo" src="build/slack_logo.png" width="70" style="vertical-align: middle" />
      <span><em>overlay</em></span>
		<div style="float: right;">
			<input
				style="height: 4px; width: 40px; display: inline-block; vertical-align: middle"
				type="range"
				min="0.01"
				max="100"
				value="34.5"
				step="0.001"
				id="brightness-slider"
			/>
			<i
				class="fas fa-adjust"
				style="
					font-size: 14px;
					display: inline-block;
					vertical-align: middle;
					margin-left: -8px;
				"
			>
			</i>
		</div>
   </header>

		<h4>ask the class channel</h4>
		<div id="threads"></div>

		<!-- socketio -->
		<script src="build/socketio.js"></script>

		<script>
			const bodyStyle = document.body.style;
			const sliderEl = document.querySelector("#brightness-slider");
			const threadsEl = document.querySelector("#threads");

			const rootThreads = {};

			const slackOptions = { headers: { Authorization: `Bearer ${process.env.token}` } };
			let users = {};

			// SLIDER
			sliderEl.oninput = function () {
				bodyStyle.background = `rgba(80, 19, 203, ${this.value / 100})`;
			};

			// fetch users
			fetch("https://slack.com/api/users.list", slackOptions)
				.then((response) => response.json())
				.then((usersList) => {
					return usersList.members.reduce((members, current) => {
						return {
							...members,
							[current.id]: {
								name: current.name,
								avatar: current.profile.image_512,
							},
						};
					}, {});
				})
				.then((members) => {
					users = members;
				})

				// fetch history
				.then(() =>
					fetch(
						`https://slack.com/api/conversations.history?inclusive=true&channel=${process.env.channel}`,
						slackOptions
					)
				)
				.then((response) => response.json())
				.then((historyThread) => {
					console.log(historyThread);
					historyThread.messages.reverse().map((thread) => {
						if (thread.type === "message") {
							threadsEl.appendChild(newMessage(thread));
						}
					});

				})
            .then(() => {
               setTimeout(() => window.scrollTo(0,document.body.clientHeight), 1000);
            })

            async function newFile(file, isReply){
               const response = await fetch(file.url_private, slackOptions);
               const image = await response.blob()
               // Then create a local URL for that image and print it 
               publicUrl = URL.createObjectURL(image)
               console.log(publicUrl)
               const imgEl = document.createElement("img");

               imgEl.setAttribute('data-zoom', 'false');
               imgEl.onclick = function () {
                  if(this.dataset.zoom === 'false'){
                     this.setAttribute('data-zoom', 'true');
                     this.style.width = "100%";
                  } else {
                     this.setAttribute('data-zoom', 'false');
                     this.style.width = "50%";
                  }
               }
               if (isReply) imgEl.style.marginLeft = "10px";
               imgEl.src = publicUrl;
               imgEl.alt = "file";
               imgEl.style.width = "50%";
               imgEl.style.marginTop = "10px";
               imgEl.style.transition="all 0.5s ease-out"
               imgEl.style.border = "1px solid #1cb7a2"

               imgEl.style.display = "block";
               return imgEl;
            }

			 function newMessage(message, isReply) {
				// create element
				const messageContainerEl = document.createElement("div");
				const messageEl = document.createElement("div");
            messageContainerEl.appendChild(messageEl);

				messageEl.textContent = message.text;
				messageEl.style.borderTop = "solid 2px #1cb7a2";
				messageEl.style.marginTop = "10px";
				messageEl.style.display = "inline-block";

				// reply style
				isReply 
               ? (messageEl.style.marginLeft = "10px") 
               : (messageEl.style.marginTop = "20px");

				// reactions
				if (message.reactions && message.reactions.length > 0) {
					message.reactions.forEach((reaction) => {
						// messageEl.appendChild(newMessage(reaction));
					});
				}

            // files
            if(message.files){

               message.files.forEach(async file => messageContainerEl.appendChild((await newFile(file, rootThreads[message.thread_ts]))))
               
            }

				// get thread
				if (message.thread_ts && !rootThreads[message.thread_ts]) {
					rootThreads[message.thread_ts] = true;

					fetch(
						`https://slack.com/api/conversations.replies?inclusive=true&channel=${process.env.channel}&ts=${message.thread_ts}`,
						slackOptions
					)
						.then((response) => response.json())
						.then((completeThread) => {
							completeThread.messages.map((block) => {
								messageContainerEl.appendChild(newMessage(block, true));
							});
						});
				}

				return messageContainerEl;
			}
			// files: [{…}]
			// reactions: (2) [{…}, {…}]
			// reply_count: 2
			// text: "mountain"
			// type: "message"
			// user: "U01NMR2RSMT"

			// socketIO
			const socket = io("https://slack-overlay-service.herokuapp.com/");

			socket.on("connect", () => {
				console.log("conected");
			});
			socket.on("broadcast", (newMessage) => {
				console.log(newMessage);
			});
		</script>
	</body>
</html>
